package nexus

import "git.enigmaneering.net/hello-world/enigma0/solution0/evolution2/core/std"

var Origin = std.Nexus{
	Entity: std.NewEntityNamed("origin"),
	Idea:   std.NewIdea[map[string]any](),
}

func Reveal[T any](endpoint string, path std.Path, code ...string) T {

}

func Describe[T any](revelation T, endpoint string, path std.Path, code ...string) {

}


To build a neural OS, we need some basic input and output systems.  The first of these we'll write
is a way to logically execute calculations at a high _frequency_ - then, we'll head to the traditional audio and
graphical components.

Enigma0 - Neural Orchestration
Step0 - A Thought - Break down a thought and why it's a gated value type
Step1 - An Idea - Break down an idea and explain the concept of local memory through nexus endpoints
Step2 - The Path - Break down the concept of a path being used to drill down INTO types, not just the nexus
Step3 - The Impulse Engine - Break down the concept of a synapse and muting (create solutions here)
Step4 - Synaptic Signaling - Break down the different kinds of signals (stimulative vs impulsive representing goroutine activation, for example)
Step5 - ARWEN - Demonstrate a very basic example of sparking off a contrived performance and the idea of how to evolve this into Autonomous Robots With Ethical Navigation

Enigma1 - tiny - Explain how to create a neural calculator
Enigma2 - Calypso - Explain how to create audio using neural activation
Enigma3 - Glitter - Explain how to create graphics using neural activation
